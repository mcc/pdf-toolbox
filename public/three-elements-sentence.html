<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏≠Êñá‰∏âÁ¥†Âè•Ê∏∏Êàè</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a friendly Chinese font -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Noto Sans SC', sans-serif;
            /* Prevents scrolling on mobile for a better drag-and-drop experience */
            touch-action: none;
        }
        .drop-zone {
            transition: background-color 0.3s, transform 0.3s;
        }
        .drag-over {
            background-color: #a7f3d0; /* Light green highlight on hover */
            transform: scale(1.05);
        }
        .card {
            touch-action: none; /* Allows dragging without page scroll on mobile */
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: scale(1.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        #feedback-popup {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        /* Fun confetti effect for correct answers */
        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd300;
            top: 0;
            opacity: 0;
            z-index: 1000;
        }
    </style>
</head>
<body class="bg-amber-100 flex items-center justify-center min-h-screen">

    <div id="game-container" class="relative w-full max-w-4xl mx-auto p-4 md:p-8 bg-white rounded-2xl shadow-2xl overflow-hidden">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-600">‰∏âÁ¥†Âè•Ê∏∏Êàè</h1>
            <p class="text-lg text-gray-500">ÊääËØçËØ≠ÊãñÂà∞Ê≠£Á°ÆÁöÑ‰ΩçÁΩÆÂêßÔºÅ</p>
        </header>

        <!-- Drop Zones for the sentence parts -->
        <div id="sentence-builder" class="grid grid-cols-3 gap-2 md:gap-4 mb-8 text-center">
            <div class="drop-container p-2 bg-sky-100 rounded-lg">
                <h2 class="text-xl font-semibold text-sky-800 mb-2">ÊôÇÈñì</h2>
                <div id="time-zone" data-type="time" class="drop-zone h-24 bg-sky-200 rounded-lg flex items-center justify-center p-2"></div>
            </div>
            <div class="drop-container p-2 bg-rose-100 rounded-lg">
                <h2 class="text-xl font-semibold text-rose-800 mb-2">‰∫∫Áâ©</h2>
                <div id="person-zone" data-type="person" class="drop-zone h-24 bg-rose-200 rounded-lg flex items-center justify-center p-2"></div>
            </div>
            <div class="drop-container p-2 bg-emerald-100 rounded-lg">
                <h2 class="text-xl font-semibold text-emerald-800 mb-2">‰∫ãÊÉÖ</h2>
                <div id="event-zone" data-type="event" class="drop-zone h-24 bg-emerald-200 rounded-lg flex items-center justify-center p-2"></div>
            </div>
        </div>

        <!-- Pool of draggable word cards -->
        <div id="card-pool" class="h-32 flex items-center justify-center gap-4 p-4 bg-gray-100 rounded-lg">
            <!-- Cards will be generated by JavaScript -->
        </div>

        <!-- Feedback Popup for when a sentence is completed -->
        <div id="feedback-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-2xl shadow-lg text-center mx-4">
                <div id="feedback-icon" class="text-6xl mb-4">üéâ</div>
                <h3 id="feedback-title" class="text-3xl font-bold text-green-600 mb-2">ÂÅöÂæóÂ•ΩÔºÅ</h3>
                <p id="feedback-sentence" class="text-2xl text-gray-700 mb-6"></p>
                <button id="next-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-xl transition-transform transform hover:scale-105">
                    ‰∏ã‰∏ÄÂè•
                </button>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Sentences based on the worksheet and other examples
            const sentences = [
                { time: 'Ê∏ÖÊô®', person: 'Âì•Âì•', event: 'ÂéªÊ∏∏Ê≥≥' },
                { time: 'Êó©‰∏ä', person: '‰∏ÄÂÆ∂‰∫∫', event: 'ÂéªÈáéÈ§ê' },
                { time: '‰ªäÂ§©', person: 'ÊàëÂíåÊúãÂèã', event: 'Áé©Á©çÊú®' },
                { time: 'ÊòüÊúüÂ§©', person: 'ÊàëÂíåÂÆ∂‰∫∫', event: 'ÁúãÈõªË¶ñ' },
                { time: '‰∏ãÂçà', person: 'Â¶πÂ¶π', event: 'Áï´ÂúñÁï´' },
                { time: 'Êôö‰∏ä', person: 'Áà∏Áà∏', event: 'ËÆÄÊïÖ‰∫ãÊõ∏' },
                { time: 'ÈÄ±Êú´', person: 'ÊàëÂÄë', event: 'ÂéªÂÖ¨Âúí' },
                { time: 'Êò®Â§©', person: 'Â™ΩÂ™Ω', event: 'ÁÉ§ËõãÁ≥ï' }
            ];

            let currentSentenceIndex = 0;
            let correctlyPlacedCount = 0;
            let shuffledSentences = shuffleArray([...sentences]);
            let draggedItem = null;

            const cardPool = document.getElementById('card-pool');
            const dropZones = document.querySelectorAll('.drop-zone');
            const feedbackPopup = document.getElementById('feedback-popup');
            const nextButton = document.getElementById('next-button');
            const feedbackSentenceEl = document.getElementById('feedback-sentence');

            // Helper to shuffle arrays randomly
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Creates a draggable card element
            function createCard(text, type) {
                const card = document.createElement('div');
                card.className = 'card bg-yellow-300 p-4 rounded-lg text-xl md:text-2xl font-bold text-yellow-800 shadow-md w-1/3 md:w-auto text-center';
                card.draggable = true;
                card.textContent = text;
                card.dataset.type = type;
                
                // Desktop drag events
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);

                // Mobile touch events
                card.addEventListener('touchstart', handleTouchStart, { passive: false });
                
                return card;
            }

            // --- Drag and Drop Logic for Desktop and Mobile ---
            
            function handleDragStart(e) {
                draggedItem = this;
                setTimeout(() => this.classList.add('dragging'), 0);
                e.dataTransfer.setData('text/plain', this.dataset.type);
            }

            function handleDragEnd() {
                this.classList.remove('dragging');
                draggedItem = null;
            }
            
            function handleTouchStart(e) {
                e.preventDefault();
                draggedItem = e.currentTarget;
                draggedItem.classList.add('dragging');

                // Add global listeners for move and end
                document.addEventListener('touchmove', handleTouchMove, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { once: true });
            }

            function handleTouchMove(e) {
                if (!draggedItem) return;
                e.preventDefault();
                
                // Find what element is under the touch point
                let touch = e.touches[0];
                draggedItem.hidden = true;
                let elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                draggedItem.hidden = false;

                // Highlight valid drop zones
                dropZones.forEach(zone => zone.classList.remove('drag-over'));
                if (elemBelow) {
                    let dropzone = elemBelow.closest('.drop-zone');
                    if (dropzone && dropzone.dataset.type === draggedItem.dataset.type) {
                        dropzone.classList.add('drag-over');
                    }
                }
            }

            function handleTouchEnd(e) {
                if (!draggedItem) return;

                // Find the drop target
                let touch = e.changedTouches[0];
                draggedItem.hidden = true;
                let elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                draggedItem.hidden = false;
                
                let dropTarget = elemBelow ? elemBelow.closest('.drop-zone') : null;
                
                // If dropped on a valid target, handle it
                if (dropTarget && dropTarget.dataset.type === draggedItem.dataset.type) {
                    handleSuccessfulDrop(draggedItem, dropTarget);
                }
                
                // Cleanup
                draggedItem.classList.remove('dragging');
                dropZones.forEach(zone => zone.classList.remove('drag-over'));
                document.removeEventListener('touchmove', handleTouchMove);
                draggedItem = null;
            }

            // Add listeners to the drop zones
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedItem && draggedItem.dataset.type === zone.dataset.type) {
                        zone.classList.add('drag-over');
                    }
                });
                zone.addEventListener('dragleave', () => {
                    zone.classList.remove('drag-over');
                });
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    if (draggedItem && draggedItem.dataset.type === e.currentTarget.dataset.type) {
                        handleSuccessfulDrop(draggedItem, e.currentTarget);
                    }
                });
            });

            function handleSuccessfulDrop(card, zone) {
                zone.innerHTML = ''; // Clear placeholder
                zone.appendChild(card);
                card.draggable = false;
                card.style.cursor = 'default';
                card.classList.remove('bg-yellow-300', 'text-yellow-800');
                
                // Set color based on type
                const typeColors = {
                    time: 'bg-sky-500 text-white',
                    person: 'bg-rose-500 text-white',
                    event: 'bg-emerald-500 text-white'
                };
                card.className = `card ${typeColors[card.dataset.type]} p-4 rounded-lg text-xl md:text-2xl font-bold shadow-md w-full h-full flex items-center justify-center text-center`;

                correctlyPlacedCount++;
                checkCompletion();
            }

            function checkCompletion() {
                if (correctlyPlacedCount === 3) {
                    setTimeout(showFeedback, 500);
                }
            }

            // --- Game Flow and Effects ---
            
            function confettiEffect() {
                const container = document.getElementById('game-container');
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti-piece';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    confetti.style.animation = `fall ${2 + Math.random() * 2}s linear ${Math.random() * 1}s forwards`;
                    container.appendChild(confetti);
                }

                const style = document.createElement('style');
                style.innerHTML = `@keyframes fall { to { transform: translateY(100vh) rotate(360deg); opacity: 0; } }`;
                document.head.appendChild(style);

                setTimeout(() => {
                    document.querySelectorAll('.confetti-piece').forEach(e => e.remove());
                    style.remove();
                }, 4000);
            }

            function showFeedback() {
                const sentence = shuffledSentences[currentSentenceIndex];
                feedbackSentenceEl.textContent = `${sentence.time}${sentence.person}${sentence.event}„ÄÇ`;
                feedbackPopup.classList.remove('hidden');
                confettiEffect();
            }

            function loadSentence(index) {
                cardPool.innerHTML = '';
                dropZones.forEach(zone => zone.innerHTML = '');
                correctlyPlacedCount = 0;

                // Loop the game if all sentences are completed
                if (index >= shuffledSentences.length) {
                    currentSentenceIndex = 0;
                    shuffledSentences = shuffleArray([...sentences]); // Reshuffle for new order
                }
                
                const sentence = shuffledSentences[currentSentenceIndex];
                const parts = [
                    { text: sentence.time, type: 'time' },
                    { text: sentence.person, type: 'person' },
                    { text: sentence.event, type: 'event' }
                ];

                shuffleArray(parts).forEach(part => {
                    const card = createCard(part.text, part.type);
                    cardPool.appendChild(card);
                });
            }

            nextButton.addEventListener('click', () => {
                feedbackPopup.classList.add('hidden');
                currentSentenceIndex++;
                loadSentence(currentSentenceIndex);
            });

            // Start the game for the first time
            loadSentence(currentSentenceIndex);
        });
    </script>

</body>
</html>
