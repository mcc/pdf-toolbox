<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一筆過解題器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            width: 100%;
            height: auto;
            max-width: 600px;
            max-height: 600px;
        }
        .mode-button {
            transition: border-width 0.2s;
        }
        .mode-button.active {
            border-width: 4px;
            border-color: #ffff00;
        }
        .button-group {
            margin-top: 0.5rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
        }
        #congratsOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 20;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen p-4">
    <h1 class="text-2xl font-bold text-gray-800 mb-4">一筆過解題器</h1>
    <canvas id="canvas" class="border border-gray-300 rounded-lg shadow-md"></canvas>
    <div class="mt-4 flex flex-wrap justify-center gap-2">
        <button id="designModeBtn" class="mode-button bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-blue-500">設計模式</button>
        <button id="gameModeBtn" class="mode-button bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-blue-500">遊戲模式</button>
    </div>
    <div id="designButtons" class="button-group">
        <button id="addNodeBtn" class="mode-button bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-blue-500">加點</button>
        <button id="addEdgeBtn" class="mode-button bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-blue-500">加邊</button>
        <button id="deleteNodeBtn" class="mode-button bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-yellow-500">刪點</button>
        <button id="undoBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-gray-500">復原</button>
    </div>
    <div id="gameButtons" class="button-group">
        <button id="stepBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-green-500">逐步解題</button>
        <button id="autoStepBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-green-500">自動解題</button>
        <button id="resetBtn" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-orange-500 hidden">重置</button>
        <button id="clearBtn" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-red-500">清除</button>
        <button id="shareBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded text-sm md:text-base border-2 border-purple-500">分享</button>
    </div>
    <div id="modeInstructions" class="mt-4 text-gray-700 max-w-md text-sm md:text-base">
        <p><strong>使用說明：</strong></p>
        <ul class="list-disc list-inside" id="instructionsList"></ul>
    </div>
    <div id="toast" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded shadow-lg hidden text-sm md:text-base z-10"></div>
    <div id="congratsOverlay" class="flex">
        <div class="bg-yellow-300 text-black p-6 rounded-lg text-center shadow-lg">
            <h2 class="text-3xl font-bold mb-4">恭喜你！🎉</h2>
            <p class="text-xl">你係一筆過大師！連蜘蛛網都唔及你咁叻！</p>
            <button id="closeCongrats" class="mt-4 bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded">繼續挑戰</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toast = document.getElementById('toast');
        const congratsOverlay = document.getElementById('congratsOverlay');
        const closeCongrats = document.getElementById('closeCongrats');
        
        const designModeBtn = document.getElementById('designModeBtn');
        const gameModeBtn = document.getElementById('gameModeBtn');
        const addNodeBtn = document.getElementById('addNodeBtn');
        const addEdgeBtn = document.getElementById('addEdgeBtn');
        const deleteNodeBtn = document.getElementById('deleteNodeBtn');
        const undoBtn = document.getElementById('undoBtn');
        const stepBtn = document.getElementById('stepBtn');
        const autoStepBtn = document.getElementById('autoStepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearBtn = document.getElementById('clearBtn');
        const shareBtn = document.getElementById('shareBtn');
        const instructionsList = document.getElementById('instructionsList');
        const designButtons = document.getElementById('designButtons');
        const gameButtons = document.getElementById('gameButtons');

        let mode = 'design'; // Default to design mode
        let subMode = 'addNode'; // Sub-mode within design mode
        let selectedNode = null;
        let nodes = [];
        let edges = [];
        let adjacency = new Map();
        let highlightedEdges = new Map();
        let problemNodes = new Set();
        let problemEdges = new Set();
        let edgePath = []; // Stores { edgeId, fromNodeId, toNodeId }
        let currentStep = 0;
        let autoInterval = null;
        let isSolved = false;
        let undoHistory = [];
        let gamePath = []; // Player's node sequence in game mode
        let gameEdges = new Map(); // Map of edge IDs to step numbers in game mode
        const GRID_SIZE = 12;
        let nextNodeId = 0;
        let nextEdgeId = 0;

        function resizeCanvas() {
            const maxSize = 600;
            const windowWidth = window.innerWidth * 0.9;
            const windowHeight = window.innerHeight * 0.6;

            let size = Math.min(windowWidth, windowHeight, maxSize);
            canvas.width = size;
            canvas.height = size;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.name = String.fromCharCode(65 + id);
                this.x = Math.max(0, Math.min(GRID_SIZE - 1, Math.round(x)));
                this.y = Math.max(0, Math.min(GRID_SIZE - 1, Math.round(y)));
            }
        }

        class Edge {
            constructor(id, node1, node2) {
                this.id = id;
                this.node1 = node1;
                this.node2 = node2;
            }
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.remove('hidden');
            setTimeout(() => { toast.classList.add('hidden'); }, 3000);
        }

        function showCongrats() {
            congratsOverlay.style.display = 'flex';
        }

        function hideCongrats() {
            congratsOverlay.style.display = 'none';
            gamePath = [];
            gameEdges.clear();
            draw();
        }

        closeCongrats.addEventListener('click', hideCongrats);

        function saveState() {
            undoHistory.push({
                nodes: nodes.map(n => ({ id: n.id, x: n.x, y: n.y })),
                edges: edges.map(e => ({ id: e.id, node1Id: e.node1.id, node2Id: e.node2.id })),
                adjacency: new Map([...adjacency].map(([k, v]) => [k, [...v]])),
                nextNodeId: nextNodeId
            });
            if (undoHistory.length > 10) undoHistory.shift();
        }

        function resetSolver() {
            highlightedEdges.clear();
            problemNodes.clear();
            problemEdges.clear();
            edgePath = [];
            currentStep = 0;
            isSolved = false;
            gamePath = [];
            gameEdges.clear();
            if (autoInterval) clearInterval(autoInterval);
            draw();
        }

        function updateButtonHighlight() {
            designModeBtn.classList.toggle('active', mode === 'design');
            gameModeBtn.classList.toggle('active', mode === 'game');
            addNodeBtn.classList.toggle('active', mode === 'design' && subMode === 'addNode');
            addEdgeBtn.classList.toggle('active', mode === 'design' && subMode === 'addEdge');
            deleteNodeBtn.classList.toggle('active', mode === 'design' && subMode === 'deleteNode');
            designButtons.classList.toggle('hidden', mode === 'game');
            stepBtn.classList.toggle('hidden', mode === 'game');
            autoStepBtn.classList.toggle('hidden', mode === 'game');
            resetBtn.classList.toggle('hidden', mode !== 'game');
            clearBtn.classList.toggle('hidden', mode === 'game');
            updateInstructions();
        }

        function updateInstructions() {
            instructionsList.innerHTML = '';
            if (mode === 'design') {
                const designInstructions = [
                    '按「加點」然後喺畫布上點擊來放置點，會自動對齊到12x12格。',
                    '按「加邊」，然後點擊兩個點來連繫佢哋。',
                    '按「刪點」，然後點擊一個點來刪除。',
                    '按「復原」取消上一個動作。',
                    '按「逐步解題」或「自動解題」來檢查是否有一筆過路徑。',
                    '用「分享」生成遊戲模式挑戰 URL 畀朋友。'
                ];
                designInstructions.forEach(text => {
                    const li = document.createElement('li');
                    li.textContent = text;
                    instructionsList.appendChild(li);
                });
            } else if (mode === 'game') {
                const gameInstructions = [
                    '點擊節點一個接一個，跟隨一筆過路徑解決挑戰（可多次經過相同節點同邊數相符）。',
                    '按「重置」重新開始遊戲。',
                    '用「分享」生成遊戲模式挑戰 URL 畀朋友。'
                ];
                gameInstructions.forEach(text => {
                    const li = document.createElement('li');
                    li.textContent = text;
                    instructionsList.appendChild(li);
                });
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cellSize = canvas.width / GRID_SIZE;

            // Draw grid lines
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }

            const nodeRadius = cellSize * 0.4;
            const fontSize = Math.max(cellSize * 0.5, 10);

            // Group edges by undirected node pair key
            const edgeGroups = new Map();
            edges.forEach(edge => {
                const key = edge.node1.id < edge.node2.id 
                    ? `${edge.node1.id}-${edge.node2.id}` 
                    : `${edge.node2.id}-${edge.node1.id}`;
                if (!edgeGroups.has(key)) edgeGroups.set(key, []);
                edgeGroups.get(key).push(edge);
            });

            edges.forEach(edge => {
                const groupKey = edge.node1.id < edge.node2.id 
                    ? `${edge.node1.id}-${edge.node2.id}` 
                    : `${edge.node2.id}-${edge.node1.id}`;
                const group = edgeGroups.get(groupKey);
                const n = group.length;
                const index = group.indexOf(edge);

                // Determine direction from edgePath or gameEdges
                let fromNode = edge.node1;
                let toNode = edge.node2;
                let isGameEdge = gameEdges.has(edge.id);
                if (isSolved && edgePath.length > 0) {
                    const pathEntry = edgePath.find(e => e.edgeId === edge.id);
                    if (pathEntry) {
                        fromNode = nodes.find(n => n.id === pathEntry.fromNodeId);
                        toNode = nodes.find(n => n.id === pathEntry.toNodeId);
                    }
                } else if (isGameEdge && gamePath.length > 1) {
                    for (let i = 0; i < gamePath.length - 1; i++) {
                        const u = gamePath[i];
                        const v = gamePath[i + 1];
                        if (((u.id === edge.node1.id && v.id === edge.node2.id) || 
                             (u.id === edge.node2.id && v.id === edge.node1.id)) && 
                            gameEdges.has(edge.id)) {
                            fromNode = u;
                            toNode = v;
                            break;
                        }
                    }
                }

                const x1 = (fromNode.x + 0.5) * cellSize;
                const y1 = (fromNode.y + 0.5) * cellSize;
                const x2 = (toNode.x + 0.5) * cellSize;
                const y2 = (toNode.y + 0.5) * cellSize;

                // Enhanced curvature calculation
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const baseCurvature = cellSize * 1.2;
                const curvatureFactor = n === 1 ? 0 : (index - (n - 1) / 2) * baseCurvature;
                const directionSign = (fromNode.id < toNode.id) ? 1 : -1;
                const perpX = -dy / dist * curvatureFactor * directionSign;
                const perpY = dx / dist * curvatureFactor * directionSign;
                const midX = (x1 + x2) / 2 + perpX;
                const midY = (y1 + y2) / 2 + perpY;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.quadraticCurveTo(midX, midY, x2, y2);
                ctx.strokeStyle = highlightedEdges.has(edge.id) ? 'red' : (isGameEdge ? 'green' : (problemEdges.has(edge.id) ? 'orange' : 'black'));
                ctx.lineWidth = highlightedEdges.has(edge.id) ? cellSize * 0.15 : (isGameEdge ? cellSize * 0.1 : cellSize * 0.05);
                ctx.stroke();

                // Add step number annotation for game mode edges
                if (mode === 'game' && isGameEdge) {
                    const stepNumber = gameEdges.get(edge.id);
                    const t = 0.5;
                    const labelX = (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * midX + t * t * x2;
                    const labelY = (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * midY + t * t * y2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(labelX - cellSize * 0.2, labelY - cellSize * 0.2, cellSize * 0.4, cellSize * 0.4);
                    ctx.fillStyle = 'black';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(stepNumber, labelX, labelY + fontSize / 3);
                } else if (highlightedEdges.has(edge.id)) {
                    const t = 0.5;
                    const labelX = (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * midX + t * t * x2;
                    const labelY = (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * midY + t * t * y2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(labelX - cellSize * 0.2, labelY - cellSize * 0.2, cellSize * 0.4, cellSize * 0.4);
                    ctx.fillStyle = 'black';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(highlightedEdges.get(edge.id), labelX, labelY + fontSize / 3);
                }
            });

            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc((node.x + 0.5) * cellSize, (node.y + 0.5) * cellSize, nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = problemNodes.has(node.id) ? 'red' : (gamePath.includes(node) ? 'green' : 'blue');
                ctx.fill();

                if (selectedNode === node && mode === 'design' && subMode === 'addEdge') {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = cellSize * 0.15;
                    ctx.stroke();
                }

                // Only draw node names in design mode
                if (mode === 'design') {
                    ctx.fillStyle = 'white';
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(node.name, (node.x + 0.5) * cellSize, (node.y + 0.5) * cellSize + fontSize / 3);
                }
            });
        }

        function getNodeAt(x, y) {
            const cellSize = canvas.scrollWidth / GRID_SIZE;
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) return null;
            return nodes.find(node => node.x === gridX && node.y === gridY);
        }

        function isGridOccupied(x, y) {
            return nodes.some(node => node.x === x && node.y === y);
        }

        function handleClick(x, y) {
            const cellSize = canvas.scrollWidth / GRID_SIZE;
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) return;

            if (mode === 'design') {
                if (subMode === 'addNode') {
                    if (!isGridOccupied(gridX, gridY)) {
                        saveState();
                        const newId = nextNodeId++;
                        const newNode = new Node(newId, gridX, gridY);
                        nodes.push(newNode);
                        adjacency.set(newId, []);
                        resetSolver();
                        draw();
                    } else {
                        showToast("此格已有一個點！");
                    }
                } else if (subMode === 'addEdge') {
                    const clickedNode = getNodeAt(x, y);
                    if (clickedNode) {
                        if (!selectedNode) {
                            selectedNode = clickedNode;
                            showToast("請點擊另一個點來連繫");
                            draw();
                        } else if (selectedNode !== clickedNode) {
                            saveState();
                            addEdge(selectedNode, clickedNode);
                            selectedNode = null;
                            draw();
                        }
                    }
                } else if (subMode === 'deleteNode') {
                    const clickedNode = getNodeAt(x, y);
                    if (clickedNode) {
                        saveState();
                        deleteNode(clickedNode);
                        draw();
                    }
                }
            } else if (mode === 'game') {
                const clickedNode = getNodeAt(x, y);
                if (clickedNode) {
                    if (gamePath.length === 0) {
                        gamePath.push(clickedNode);
                        showToast("開始你的路徑！");
                        draw();
                    } else {
                        const lastNode = gamePath[gamePath.length - 1];
                        // Find an untraveled edge between lastNode and clickedNode
                        const availableEdges = edges.filter(e => 
                            ((e.node1.id === lastNode.id && e.node2.id === clickedNode.id) || 
                             (e.node2.id === lastNode.id && e.node1.id === clickedNode.id)) && 
                            !gameEdges.has(e.id)
                        );
                        if (availableEdges.length > 0) {
                            const edge = availableEdges[0]; // Use the first untraveled edge
                            gamePath.push(clickedNode);
                            gameEdges.set(edge.id, gamePath.length - 1); // Store step number (1-based)
                            draw();
                            if (gamePath.length === edges.length + 1) {
                                const isEulerPath = checkEulerPath(gamePath);
                                if (isEulerPath) {
                                    showCongrats();
                                } else {
                                    showToast("路徑唔啱，請再試！");
                                    gamePath = [];
                                    gameEdges.clear();
                                    draw();
                                }
                            }
                        } else {
                            showToast("無未走過嘅邊連繫，請再試！");
                        }
                    }
                }
            }
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleClick(x, y);
        });

        canvas.addEventListener('touchstart', (event) => {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            handleClick(x, y);
        }, { passive: false });

        function addEdge(node1, node2) {
            const edgeId = nextEdgeId++;
            const newEdge = new Edge(edgeId, node1, node2);
            edges.push(newEdge);
            adjacency.get(node1.id).push({neighbor: node2.id, edgeId: edgeId});
            adjacency.get(node2.id).push({neighbor: node1.id, edgeId: edgeId});
            resetSolver();
        }

        function deleteNode(node) {
            nodes = nodes.filter(n => n.id !== node.id);
            edges = edges.filter(e => e.node1.id !== node.id && e.node2.id !== node.id);
            adjacency.delete(node.id);
            for (const [id, neighbors] of adjacency) {
                adjacency.set(id, neighbors.filter(n => n.neighbor !== node.id));
            }
            resetSolver();
        }

        function undo() {
            if (undoHistory.length === 0) {
                showToast("無動作可以復原！");
                return;
            }
            const lastState = undoHistory.pop();
            nodes = lastState.nodes.map(n => new Node(n.id, n.x, n.y));
            edges = [];
            adjacency = new Map();
            nodes.forEach(n => adjacency.set(n.id, []));
            lastState.edges.forEach(e => {
                const node1 = nodes.find(n => n.id === e.node1Id);
                const node2 = nodes.find(n => n.id === e.node2Id);
                if (node1 && node2) {
                    const edgeId = e.id;
                    const newEdge = new Edge(edgeId, node1, node2);
                    edges.push(newEdge);
                    adjacency.get(node1.id).push({neighbor: node2.id, edgeId: edgeId});
                    adjacency.get(node2.id).push({neighbor: node1.id, edgeId: edgeId});
                }
            });
            nextNodeId = lastState.nextNodeId;
            nextEdgeId = edges.length > 0 ? Math.max(...edges.map(e => e.id)) + 1 : 0;
            selectedNode = null;
            resetSolver();
            draw();
        }

        designModeBtn.addEventListener('click', () => {
            mode = 'design';
            subMode = 'addNode';
            resetSolver();
            updateButtonHighlight();
            showToast("進入設計模式");
        });

        gameModeBtn.addEventListener('click', () => {
            if (nodes.length === 0 || edges.length === 0) {
                showToast("請先設計一個圖表！");
                return;
            }
            if (solve()) { // Check if Euler path exists
                mode = 'game';
                resetSolver();
                updateButtonHighlight();
                showToast("進入遊戲模式");
            } else {
                showToast("此圖表無一筆過路徑，無法進入遊戲模式！");
            }
        });

        addNodeBtn.addEventListener('click', () => { 
            if (mode === 'design') {
                subMode = 'addNode'; 
                selectedNode = null; 
                showToast("加點模式：請喺畫布上點擊");
                updateButtonHighlight();
                draw(); 
            }
        });
        addEdgeBtn.addEventListener('click', () => { 
            if (mode === 'design') {
                subMode = 'addEdge'; 
                selectedNode = null; 
                showToast("加邊模式：請點擊兩個點");
                updateButtonHighlight();
                draw(); 
            }
        });
        deleteNodeBtn.addEventListener('click', () => { 
            if (mode === 'design') {
                subMode = 'deleteNode'; 
                selectedNode = null; 
                showToast("刪點模式：請點擊一個點");
                updateButtonHighlight();
                draw(); 
            }
        });
        undoBtn.addEventListener('click', undo);
        stepBtn.addEventListener('click', solveStep);
        autoStepBtn.addEventListener('click', autoSolve);
        resetBtn.addEventListener('click', () => {
            if (mode === 'game') {
                gamePath = [];
                gameEdges.clear();
                draw();
                showToast("遊戲已重置");
            }
        });
        clearBtn.addEventListener('click', clear);
        shareBtn.addEventListener('click', share);

        function clear() {
            nodes = [];
            edges = [];
            adjacency.clear();
            selectedNode = null;
            undoHistory = [];
            nextNodeId = 0;
            nextEdgeId = 0;
            mode = 'design'; // Reset to design mode
            subMode = 'addNode';
            resetSolver();
            updateButtonHighlight();
            draw();
        }

        function dfs(nodeId, visited) {
            visited.add(nodeId);
            for (const entry of adjacency.get(nodeId)) {
                if (!visited.has(entry.neighbor)) {
                    dfs(entry.neighbor, visited);
                }
            }
        }

        function isConnected() {
            let startNode = null;
            for (const node of nodes) {
                if (adjacency.get(node.id).length > 0) {
                    startNode = node.id;
                    break;
                }
            }
            if (!startNode) return true;
            const visited = new Set();
            dfs(startNode, visited);
            for (const node of nodes) {
                if (adjacency.get(node.id).length > 0 && !visited.has(node.id)) {
                    return false;
                }
            }
            return true;
        }

        function calculateDegrees() {
            const degrees = new Map();
            for (const node of nodes) {
                degrees.set(node.id, adjacency.get(node.id).length);
            }
            return degrees;
        }

        function findEulerianPath(start) {
            const adjCopy = new Map();
            for (const [nodeId, entries] of adjacency) {
                adjCopy.set(nodeId, [...entries]);
            }

            const path = [];
            const edgeStack = [];

            function removeEdge(nodeId, edgeId) {
                const neighbors = adjCopy.get(nodeId);
                const index = neighbors.findIndex(e => e.edgeId === edgeId);
                if (index !== -1) neighbors.splice(index, 1);
            }

            function findCircuit(current) {
                const circuit = [{ nodeId: current, edgeId: null }];
                let u = current;

                while (adjCopy.get(u).length > 0) {
                    const {neighbor, edgeId} = adjCopy.get(u)[0];
                    removeEdge(u, edgeId);
                    removeEdge(neighbor, edgeId);
                    edgeStack.push(edgeId);
                    circuit.push({ nodeId: neighbor, edgeId: edgeId });
                    u = neighbor;
                }

                return circuit;
            }

            let currentPath = findCircuit(start);
            path.push(...currentPath);

            while (edgeStack.length > 0) {
                let subStart = null;
                for (let i = 0; i < path.length; i++) {
                    if (adjCopy.get(path[i].nodeId).length > 0) {
                        subStart = path[i].nodeId;
                        break;
                    }
                }

                if (!subStart) break;

                const subCircuit = findCircuit(subStart);
                const insertPos = path.findIndex(p => p.nodeId === subStart);
                path.splice(insertPos + 1, 0, ...subCircuit.slice(1));
            }

            const finalEdgePath = [];
            for (let i = 0; i < path.length - 1; i++) {
                const fromNodeId = path[i].nodeId;
                const toNodeId = path[i + 1].nodeId;
                const edgeId = path[i + 1].edgeId;
                finalEdgePath.push({ edgeId, fromNodeId, toNodeId });
            }

            return finalEdgePath;
        }

        function checkEulerPath(playerPath) {
            if (playerPath.length !== edges.length + 1) return false;

            // Convert playerPath to edge IDs based on gameEdges
            const usedEdgeIds = new Set();
            for (let i = 0; i < playerPath.length - 1; i++) {
                const u = playerPath[i];
                const v = playerPath[i + 1];
                const edge = edges.find(e => 
                    ((e.node1.id === u.id && e.node2.id === v.id) || 
                     (e.node2.id === u.id && e.node1.id === v.id)) && 
                    gameEdges.has(e.id) && !usedEdgeIds.has(e.id)
                );
                if (!edge) return false;
                usedEdgeIds.add(edge.id);
            }

            // Check if all edges in the graph are used exactly once
            const allEdgeIds = new Set(edges.map(e => e.id));
            if (usedEdgeIds.size !== allEdgeIds.size) return false;
            for (let edgeId of allEdgeIds) {
                if (!usedEdgeIds.has(edgeId)) return false;
            }
            return true;
        }

        function solve() {
            if (nodes.length === 0) {
                showToast("請至少加一個點。");
                return false;
            }
            if (edges.length === 0) {
                showToast("請至少加一條邊。");
                return false;
            }
            if (!isConnected()) {
                showToast("圖表唔連繫。");
                return false;
            }

            const degrees = calculateDegrees();
            const oddDegreeNodes = [];
            for (const [nodeId, degree] of degrees) {
                if (degree % 2 === 1) {
                    oddDegreeNodes.push(nodeId);
                }
            }

            if (oddDegreeNodes.length > 2) {
                showToast("無一筆過路徑（多過兩個奇數度點）。");
                problemNodes.clear();
                problemEdges.clear();
                oddDegreeNodes.forEach(id => problemNodes.add(id));
                edges.forEach(edge => {
                    if (problemNodes.has(edge.node1.id) || problemNodes.has(edge.node2.id)) {
                        problemEdges.add(edge.id);
                    }
                });
                draw();
                return false;
            }

            let startNode;
            if (oddDegreeNodes.length === 0) {
                startNode = nodes.find(node => degrees.get(node.id) > 0)?.id;
            } else {
                startNode = oddDegreeNodes[0];
            }

            edgePath = findEulerianPath(startNode);
            currentStep = 0;
            highlightedEdges.clear();
            problemNodes.clear();
            problemEdges.clear();
            isSolved = true;
            draw();
            return true;
        }

        function solveStep() {
            if (!isSolved) {
                if (!solve()) return;
            } else if (currentStep >= edgePath.length) {
                resetSolver();
                if (!solve()) return;
            }
            if (currentStep < edgePath.length) {
                highlightedEdges.set(edgePath[currentStep].edgeId, currentStep + 1);
                currentStep++;
                draw();
            } else if (currentStep === edgePath.length) {
                showToast("路徑完成！");
            }
        }

        function autoSolve() {
            if (autoInterval) clearInterval(autoInterval);
            if (!isSolved) {
                if (!solve()) return;
            } else if (currentStep >= edgePath.length) {
                resetSolver();
                if (!solve()) return;
            }
            autoInterval = setInterval(() => {
                if (currentStep < edgePath.length) {
                    highlightedEdges.set(edgePath[currentStep].edgeId, currentStep + 1);
                    currentStep++;
                    draw();
                } else {
                    clearInterval(autoInterval);
                    showToast("路徑完成！");
                }
            }, 1000);
        }

        function share() {
            if (nodes.length === 0) {
                showToast("未有嘢可以分享！");
                return;
            }
            let nodeStr = nodes.map(n => `${n.id},${n.x},${n.y}`).join('|');
            let edgeStr = edges.map(e => `${e.node1.id}-${e.node2.id}`).join('|');
            const graphData = `n${nodeStr};e${edgeStr}`;
            const encodedData = encodeURIComponent(graphData);
            const url = `${window.location.origin}${window.location.pathname}?graph=${encodedData}&mode=game`;
            navigator.clipboard.writeText(url).then(() => {
                showToast("遊戲模式挑戰 URL 已複製到剪貼簿！");
            });
        }

        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const graphParam = urlParams.get('graph');
            const modeParam = urlParams.get('mode');
            if (graphParam) {
                try {
                    const graphData = decodeURIComponent(graphParam);
                    const [nodePart, edgePart] = graphData.split(';');
                    if (nodePart.startsWith('n')) {
                        const nodeCoords = nodePart.slice(1).split('|').filter(Boolean);
                        nodes = nodeCoords.map(coord => {
                            const [id, x, y] = coord.split(',').map(Number);
                            return new Node(id, x, y);
                        });
                        nodes.forEach(n => adjacency.set(n.id, []));
                        nextNodeId = nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 0;
                    }
                    if (edgePart && edgePart.startsWith('e')) {
                        const edgePairs = edgePart.slice(1).split('|').filter(Boolean);
                        edgePairs.forEach(pair => {
                            const [n1, n2] = pair.split('-').map(Number);
                            const node1 = nodes.find(n => n.id === n1);
                            const node2 = nodes.find(n => n.id === n2);
                            if (node1 && node2) addEdge(node1, node2);
                        });
                    }
                    draw();
                    if (modeParam === 'game' && nodes.length > 0 && edges.length > 0 && solve()) {
                        mode = 'game';
                        resetSolver();
                        updateButtonHighlight();
                        showToast("已載入遊戲模式挑戰！");
                    } else {
                        mode = 'design';
                        subMode = 'addNode';
                        updateButtonHighlight();
                        if (modeParam === 'game' && !solve()) {
                            showToast("此圖表無一筆過路徑，已載入設計模式！");
                        }
                    }
                } catch (e) {
                    showToast("無法從 URL 載入圖表。");
                }
            } else {
                updateButtonHighlight();
            }
        }

        loadFromURL();
    </script>
</body>
</html>