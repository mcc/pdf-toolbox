<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go (Weiqi) - Traditional AI</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-color: #e3ac67;
            --board-shadow: #8d5e2a;
            --text-color: #ecf0f1;
            --accent-color: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        header {
            text-align: center;
            padding: 20px;
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: var(--text-color);
            color: var(--bg-color);
            transition: transform 0.1s, background-color 0.2s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            background-color: #bdc3c7;
        }

        button.active {
            background-color: var(--accent-color);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #game-container {
            position: relative;
            margin: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border-radius: 4px;
            background-color: var(--board-color);
            padding: 20px; /* Padding for the wood border */
        }

        canvas {
            display: block;
            cursor: crosshair;
            background-color: var(--board-color);
            touch-action: none; /* Prevent scrolling on mobile */
        }

        .status-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-top: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stone-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .stone-black { background: #000; border: 1px solid #333; }
        .stone-white { background: #fff; border: 1px solid #ccc; }

        #message-area {
            height: 30px;
            margin-top: 10px;
            color: #f1c40f;
            font-weight: bold;
            text-align: center;
        }

        /* Modal for Game Over */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: #fff;
            color: #333;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        .modal-content h2 { margin-top: 0; color: var(--bg-color); }
    </style>
</head>
<body>

<header>
    <h1>GO <span style="font-size: 0.6em; opacity: 0.7;">(WEIQI)</span></h1>
    <div class="controls">
        <select id="board-size" style="padding: 10px; border-radius: 4px; border: none;">
            <option value="9">9x9 (Fast)</option>
            <option value="13">13x13 (Standard)</option>
            <option value="19">19x19 (Full)</option>
        </select>
        <button id="btn-new-game">New Game</button>
        <button id="btn-pass">Pass Turn</button>
        <button id="btn-undo">Undo</button>
    </div>
</header>

<div class="status-panel">
    <div class="player-info">
        <div class="stone-icon stone-black"></div>
        <span>Black (You): <span id="score-black">0</span> captures</span>
    </div>
    <div class="player-info">
        <span>White (AI): <span id="score-white">0</span> captures</span>
        <div class="stone-icon stone-white"></div>
    </div>
</div>

<div id="message-area"></div>

<div id="game-container">
    <canvas id="go-board"></canvas>
</div>

<!-- Modal -->
<div id="modal-overlay">
    <div class="modal-content">
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-msg">Result here...</p>
        <button onclick="closeModal()">Close</button>
        <button onclick="startNewGame()">Play Again</button>
    </div>
</div>

<script>
/**
 * GO GAME LOGIC & AI
 * -------------------
 * Concepts:
 * 0: Empty, 1: Black, 2: White
 */

const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

class GoEngine {
    constructor(size) {
        this.size = size;
        this.board = new Int8Array(size * size).fill(EMPTY);
        this.captures = { [BLACK]: 0, [WHITE]: 0 };
        this.history = []; // For Undo and Ko checks
        this.lastMove = null; // {x, y, color}
        this.passes = 0;
        this.turn = BLACK;
        this.gameOver = false;
    }

    // Helper to get 1D index from 2D coords
    idx(x, y) {
        return y * this.size + x;
    }

    // Helper to get 2D coords from 1D index
    coords(i) {
        return { x: i % this.size, y: Math.floor(i / this.size) };
    }

    isValid(x, y) {
        return x >= 0 && x < this.size && y >= 0 && y < this.size;
    }

    // Main move function
    playMove(x, y) {
        if (this.gameOver) return false;
        if (!this.isValid(x, y)) return false;
        if (this.board[this.idx(x, y)] !== EMPTY) return false;

        // 1. Temporarily place stone
        const originalBoard = new Int8Array(this.board);
        this.board[this.idx(x, y)] = this.turn;
        
        const opponent = this.turn === BLACK ? WHITE : BLACK;
        let capturedStones = [];

        // 2. Check for captures of opponent (Orthogonal neighbors)
        const neighbors = this.getNeighbors(x, y);
        neighbors.forEach(n => {
            if (this.board[this.idx(n.x, n.y)] === opponent) {
                const group = this.getGroup(n.x, n.y);
                if (this.countLiberties(group) === 0) {
                    // Capture!
                    group.forEach(idx => {
                        this.board[idx] = EMPTY;
                        capturedStones.push(idx);
                    });
                }
            }
        });

        // 3. Check for Suicide (My own group has 0 liberties)
        const myGroup = this.getGroup(x, y);
        if (this.countLiberties(myGroup) === 0) {
            // Revert (Suicide is illegal unless it captured something, 
            // but simplified rules often ban suicide entirely. 
            // Standard: valid if it captures opponent stones. 
            // Since we already removed opponents in step 2, if we still have 0 libs, it's suicide.)
            this.board = originalBoard;
            return { success: false, reason: "Suicide move is forbidden." };
        }

        // 4. Check Ko Rule (Cannot repeat exact board state)
        if (this.isKoViolation()) {
            this.board = originalBoard;
            return { success: false, reason: "Ko rule violation." };
        }

        // Move is valid
        this.captures[this.turn] += capturedStones.length;
        this.history.push({
            board: new Int8Array(originalBoard), // Store PREVIOUS state
            captures: {...this.captures},
            turn: this.turn,
            lastMove: this.lastMove
        });

        this.lastMove = {x, y, color: this.turn};
        this.turn = opponent;
        this.passes = 0;
        return { success: true, captured: capturedStones.length };
    }

    pass() {
        if (this.gameOver) return;
        this.history.push({
            board: new Int8Array(this.board),
            captures: {...this.captures},
            turn: this.turn,
            lastMove: this.lastMove
        });
        this.passes++;
        this.turn = this.turn === BLACK ? WHITE : BLACK;
        this.lastMove = null;
        if (this.passes >= 2) {
            this.endGame();
        }
    }

    undo() {
        if (this.history.length === 0) return false;
        const state = this.history.pop();
        this.board = state.board;
        this.captures = state.captures;
        this.turn = state.turn;
        this.lastMove = state.lastMove;
        this.passes = 0;
        this.gameOver = false;
        return true;
    }

    getNeighbors(x, y) {
        const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        const neighbors = [];
        dirs.forEach(d => {
            const nx = x + d[0];
            const ny = y + d[1];
            if (this.isValid(nx, ny)) neighbors.push({x: nx, y: ny});
        });
        return neighbors;
    }

    // Flood fill to find connected stones of same color
    getGroup(x, y) {
        const color = this.board[this.idx(x, y)];
        const group = new Set();
        const stack = [{x, y}];
        group.add(this.idx(x, y));

        while (stack.length > 0) {
            const curr = stack.pop();
            const neighbors = this.getNeighbors(curr.x, curr.y);
            neighbors.forEach(n => {
                const idx = this.idx(n.x, n.y);
                if (this.board[idx] === color && !group.has(idx)) {
                    group.add(idx);
                    stack.push(n);
                }
            });
        }
        return Array.from(group); // Returns array of 1D indices
    }

    countLiberties(groupIndices) {
        const liberties = new Set();
        groupIndices.forEach(idx => {
            const c = this.coords(idx);
            const neighbors = this.getNeighbors(c.x, c.y);
            neighbors.forEach(n => {
                if (this.board[this.idx(n.x, n.y)] === EMPTY) {
                    liberties.add(this.idx(n.x, n.y));
                }
            });
        });
        return liberties.size;
    }

    isKoViolation() {
        // Simple Ko check: check if current board matches *immediate* previous board-2 state?
        // Actually standard Ko checks against immediately previous position is not enough for superko,
        // but basic Ko is just preventing returning to the state 1 move ago.
        // We iterate history to be safe (Positional Superko).
        // For performance, we can just check the history[length-2], but let's do full check.
        // JS Int8Array comparison stringified for ease.
        
        if (this.history.length < 1) return false;
        
        const currentStr = this.board.toString();
        // We only really need to check if we recreated the board from 2 moves ago?
        // Basic Ko:
        for(let i = this.history.length - 1; i >= 0; i--) {
             if (this.history[i].board.toString() === currentStr && this.history[i].turn === this.turn) {
                 return true;
             }
             // Optimization: Basic Ko usually only recurs after 2 plies.
             // If we want full Superko, keep loop. If just Basic Ko, check just history[len-1] logic?
             // Actually, history stores the state BEFORE the move.
        }
        return false;
    }

    endGame() {
        this.gameOver = true;
    }
}

/**
 * TRADITIONAL HEURISTIC AI (No ML)
 * --------------------------------
 * Rules of Thumb:
 * 1. Can I capture? (Atari) -> Do it.
 * 2. Am I in danger? (My group has 1 liberty) -> Save it.
 * 3. Pattern Matching -> Hane, Connect, Cut.
 * 4. General Spacing -> Don't play too close to thickness, play on 3rd/4th line.
 */
class GoAI {
    constructor(engine) {
        this.eng = engine;
        this.myColor = WHITE;
    }

    generateMove() {
        const size = this.eng.size;
        const candidates = [];
        
        // 1. URGENT: Check for ATARI (Groups with 1 liberty)
        // Check my groups to save, Enemy groups to kill
        let urgentMove = this.findAtariMove();
        if (urgentMove) return urgentMove;

        // 2. HEURISTIC SCORING
        // Evaluate every empty spot
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (this.eng.board[this.eng.idx(x, y)] === EMPTY) {
                    const score = this.evaluateSpot(x, y);
                    if (score > -1000) { // Filter out suicide/illegal
                        candidates.push({x, y, score});
                    }
                }
            }
        }

        // Sort by score
        candidates.sort((a, b) => b.score - a.score);

        // Add some randomness to top moves to avoid robotic repetition
        const topCandidates = candidates.slice(0, 5);
        if (topCandidates.length > 0) {
            // Weighted random choice
            const r = Math.floor(Math.random() * topCandidates.length);
            return topCandidates[r];
        }

        return null; // Pass
    }

    findAtariMove() {
        // Iterate all groups
        const visited = new Set();
        
        for (let i = 0; i < this.eng.board.length; i++) {
            if (this.eng.board[i] !== EMPTY && !visited.has(i)) {
                const c = this.eng.coords(i);
                const group = this.eng.getGroup(c.x, c.y);
                const color = this.eng.board[i];
                const libs = this.eng.countLiberties(group);

                group.forEach(idx => visited.add(idx));

                if (libs === 1) {
                    // Find the liberty spot
                    const libertyIdx = this.findSingleLiberty(group);
                    if (libertyIdx !== -1) {
                        const libC = this.eng.coords(libertyIdx);
                        
                        // If it's enemy (Black), KILL IT
                        if (color !== this.myColor) {
                            // Verify move is valid
                            if (this.isMoveValid(libC.x, libC.y)) {
                                return {x: libC.x, y: libC.y, type: 'capture'};
                            }
                        }
                        // If it's mine (White), SAVE IT
                        else {
                            // Check if playing there actually increases liberties (not a self-fill into death)
                            if (this.doesMoveIncreaseLiberties(libC.x, libC.y, group)) {
                                return {x: libC.x, y: libC.y, type: 'save'};
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    findSingleLiberty(group) {
        for (let idx of group) {
            const c = this.eng.coords(idx);
            const neighbors = this.eng.getNeighbors(c.x, c.y);
            for (let n of neighbors) {
                if (this.eng.board[this.eng.idx(n.x, n.y)] === EMPTY) {
                    return this.eng.idx(n.x, n.y);
                }
            }
        }
        return -1;
    }

    // Quick check if playing at x,y is legally playable for AI
    isMoveValid(x, y) {
        // Clone board to test
        const originalBoard = new Int8Array(this.eng.board);
        this.eng.board[this.eng.idx(x, y)] = this.myColor;
        
        // Check capture of self (suicide)
        const myGroup = this.eng.getGroup(x, y);
        const libs = this.eng.countLiberties(myGroup);
        
        // Restore
        this.eng.board = originalBoard;

        // Note: This doesn't account for capturing enemy to gain liberties (complex), 
        // but acts as a safety filter.
        return libs > 0;
    }

    doesMoveIncreaseLiberties(x, y, originalGroup) {
        // Simulate move
        const originalBoard = new Int8Array(this.eng.board);
        this.eng.board[this.eng.idx(x, y)] = this.myColor;
        
        const newGroup = this.eng.getGroup(x, y);
        const newLibs = this.eng.countLiberties(newGroup);
        
        this.eng.board = originalBoard;
        return newLibs > 1; // 1 means we are still in atari, >1 is safe
    }

    evaluateSpot(x, y) {
        let score = 0;

        // 0. Safety Check
        if (!this.isMoveValid(x, y)) return -9999;

        // 1. Distance from center (Star points preferred in opening)
        // 3rd and 4th lines are gold. 1st line (edge) is trash early on.
        const dX = Math.min(x, this.eng.size - 1 - x);
        const dY = Math.min(y, this.eng.size - 1 - y);
        const minEdgeDist = Math.min(dX, dY); // 0 = edge

        if (minEdgeDist === 0) score -= 5; // Avoid edge early
        if (minEdgeDist === 2) score += 3; // 3rd line (Territory)
        if (minEdgeDist === 3) score += 3; // 4th line (Influence)
        if (minEdgeDist === 1) score -= 2; // 2nd line is usually low

        // 2. Local Patterns (3x3 neighborhood)
        const neighbors = this.eng.getNeighbors(x, y);
        let enemyStones = 0;
        let myStones = 0;

        neighbors.forEach(n => {
            const cell = this.eng.board[this.eng.idx(n.x, n.y)];
            if (cell === BLACK) enemyStones++;
            if (cell === WHITE) myStones++;
        });

        // Hane or Attachment
        if (enemyStones > 0) score += 2; 
        // Connection
        if (myStones > 0) score += 1;

        // Empty Triangle detection (Bad shape)
        // If playing here forms an 'L' shape of 3 stones with no enemy in the 'corner' of the L... 
        // Simplified: penalize clumping.
        if (myStones >= 2) score -= 1; 

        // 3. Random noise to make it less deterministic
        score += Math.random() * 2;

        return score;
    }
}

/**
 * UI & CONTROLLER
 */
const canvas = document.getElementById('go-board');
const ctx = canvas.getContext('2d');
const msgArea = document.getElementById('message-area');
const scoreBlack = document.getElementById('score-black');
const scoreWhite = document.getElementById('score-white');

// Game State
let engine;
let ai;
let cellSize;
let boardPadding = 30;

function initGame(size = 9) {
    engine = new GoEngine(size);
    ai = new GoAI(engine);
    resizeBoard();
    drawBoard();
    updateUI();
    document.getElementById('modal-overlay').style.display = 'none';
}

function resizeBoard() {
    const container = document.getElementById('game-container');
    const size = Math.min(window.innerWidth - 40, 600); // Max width 600
    canvas.width = size;
    canvas.height = size;
    
    // Calculate cell size based on board size (9, 13, 19)
    // Board grid is (size-1) squares wide
    const playableWidth = size - (boardPadding * 2);
    cellSize = playableWidth / (engine.size - 1);
}

function drawBoard() {
    // 1. Wood Texture Background
    ctx.fillStyle = '#e3ac67';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add wood grain effect
    ctx.globalAlpha = 0.1;
    for(let i=0; i<100; i++) {
        ctx.fillStyle = '#5d4037';
        const w = Math.random() * canvas.width;
        const h = Math.random() * 5;
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        ctx.fillRect(x, y, w, h);
    }
    ctx.globalAlpha = 1.0;

    // 2. Grid Lines
    ctx.beginPath();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;

    for (let i = 0; i < engine.size; i++) {
        // Vertical
        const x = boardPadding + i * cellSize;
        ctx.moveTo(x, boardPadding);
        ctx.lineTo(x, canvas.height - boardPadding);

        // Horizontal
        const y = boardPadding + i * cellSize;
        ctx.moveTo(boardPadding, y);
        ctx.lineTo(canvas.width - boardPadding, y);
    }
    ctx.stroke();

    // 3. Star Points (Hoshi)
    const starPoints = getStarPoints(engine.size);
    ctx.fillStyle = '#000';
    starPoints.forEach(p => {
        const x = boardPadding + p.x * cellSize;
        const y = boardPadding + p.y * cellSize;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
    });

    // 4. Stones
    // Shadow first
    for (let y = 0; y < engine.size; y++) {
        for (let x = 0; x < engine.size; x++) {
            const cell = engine.board[engine.idx(x, y)];
            if (cell !== EMPTY) {
                const cx = boardPadding + x * cellSize;
                const cy = boardPadding + y * cellSize;
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(cx + 2, cy + 2, cellSize * 0.45, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // Stones body
    for (let y = 0; y < engine.size; y++) {
        for (let x = 0; x < engine.size; x++) {
            const cell = engine.board[engine.idx(x, y)];
            if (cell !== EMPTY) {
                const cx = boardPadding + x * cellSize;
                const cy = boardPadding + y * cellSize;
                const radius = cellSize * 0.46;

                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);

                if (cell === BLACK) {
                    const grad = ctx.createRadialGradient(cx - radius/3, cy - radius/3, radius/10, cx, cy, radius);
                    grad.addColorStop(0, '#555');
                    grad.addColorStop(1, '#000');
                    ctx.fillStyle = grad;
                } else {
                    const grad = ctx.createRadialGradient(cx - radius/3, cy - radius/3, radius/10, cx, cy, radius);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(1, '#ddd');
                    ctx.fillStyle = grad;
                }
                ctx.fill();
                
                // Last move marker
                if (engine.lastMove && engine.lastMove.x === x && engine.lastMove.y === y) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius/2, 0, Math.PI * 2);
                    ctx.strokeStyle = cell === BLACK ? 'white' : 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }
    }
}

function getStarPoints(size) {
    if (size === 9) return [{x:2, y:2}, {x:6, y:2}, {x:4, y:4}, {x:2, y:6}, {x:6, y:6}];
    if (size === 13) return [{x:3, y:3}, {x:9, y:3}, {x:6, y:6}, {x:3, y:9}, {x:9, y:9}];
    if (size === 19) return [
        {x:3,y:3}, {x:9,y:3}, {x:15,y:3},
        {x:3,y:9}, {x:9,y:9}, {x:15,y:9},
        {x:3,y:15}, {x:9,y:15}, {x:15,y:15}
    ];
    return [];
}

function updateUI() {
    scoreBlack.innerText = engine.captures[BLACK];
    scoreWhite.innerText = engine.captures[WHITE];
    
    if (engine.gameOver) return;

    if (engine.turn === BLACK) {
        msgArea.innerText = "Your Turn (Black)";
        msgArea.style.color = "#000";
    } else {
        msgArea.innerText = "AI Thinking...";
        msgArea.style.color = "#fff";
        setTimeout(playAI, 100); // Small delay for UI update
    }
}

function playAI() {
    if (engine.gameOver) return;
    const move = ai.generateMove();
    if (move) {
        const result = engine.playMove(move.x, move.y);
        if (result.success) {
            playSound('stone');
        } else {
            engine.pass(); // Should not happen with current AI logic
        }
    } else {
        engine.pass();
        showMessage("AI Passed");
    }
    drawBoard();
    updateUI();
    checkGameOver();
}

function showMessage(txt) {
    msgArea.innerText = txt;
}

function checkGameOver() {
    if (engine.gameOver) {
        // Calculate rough score (Area scoring simplified: stones on board + captures)
        // Note: Full territory counting is complex to code from scratch without dead stone selection.
        // We will use Stone Counting + Captures for this simplified implementation.
        let blackScore = engine.captures[BLACK];
        let whiteScore = engine.captures[WHITE];
        
        // Count stones on board
        engine.board.forEach(cell => {
            if (cell === BLACK) blackScore++;
            if (cell === WHITE) whiteScore++;
        });

        // Komi (Compensation for white moving second)
        const komi = 6.5;
        whiteScore += komi;

        const winner = blackScore > whiteScore ? "Black" : "White";
        const msg = `Black: ${blackScore} (Stones+Caps) | White: ${whiteScore} (Inc. ${komi} Komi)`;
        
        document.getElementById('modal-title').innerText = winner + " Wins!";
        document.getElementById('modal-msg').innerText = msg;
        document.getElementById('modal-overlay').style.display = 'flex';
    }
}

// User Interaction
canvas.addEventListener('click', (e) => {
    if (engine.turn !== BLACK || engine.gameOver) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left - boardPadding;
    const y = e.clientY - rect.top - boardPadding;
    
    // Find nearest intersection
    // Need to round to nearest grid point
    const gridX = Math.round(x / cellSize);
    const gridY = Math.round(y / cellSize);

    // Click threshold to avoid misclicks between lines
    const screenX = boardPadding + gridX * cellSize;
    const screenY = boardPadding + gridY * cellSize;
    const dist = Math.sqrt(Math.pow(e.clientX - rect.left - screenX, 2) + Math.pow(e.clientY - rect.top - screenY, 2));

    if (dist < cellSize * 0.4) {
        const result = engine.playMove(gridX, gridY);
        if (result.success) {
            playSound('stone');
            drawBoard();
            updateUI();
        } else {
            showMessage(result.reason || "Invalid Move");
            shakeBoard();
        }
    }
});

// Controls
document.getElementById('btn-new-game').addEventListener('click', startNewGame);
document.getElementById('btn-pass').addEventListener('click', () => {
    if (engine.turn === BLACK && !engine.gameOver) {
        engine.pass();
        drawBoard();
        updateUI();
        checkGameOver();
    }
});
document.getElementById('btn-undo').addEventListener('click', () => {
    // Undo twice (AI and Player)
    if(engine.undo()) {
        engine.undo(); 
        drawBoard();
        updateUI();
    }
});
document.getElementById('board-size').addEventListener('change', startNewGame);

function startNewGame() {
    const size = parseInt(document.getElementById('board-size').value);
    initGame(size);
}

function closeModal() {
    document.getElementById('modal-overlay').style.display = 'none';
}

function shakeBoard() {
    const c = document.getElementById('game-container');
    c.style.transform = "translateX(5px)";
    setTimeout(() => c.style.transform = "translateX(-5px)", 50);
    setTimeout(() => c.style.transform = "translateX(5px)", 100);
    setTimeout(() => c.style.transform = "none", 150);
}

// Simple Audio Synth for Stone Clack
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    if (type === 'stone') {
        // Sharp clack sound
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }
}

// Handle Window Resize
window.addEventListener('resize', () => {
    resizeBoard();
    drawBoard();
});

// Start
initGame(9);

</script>
</body>
</html>