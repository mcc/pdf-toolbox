<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Image Extractor</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="/tools/css/tailwindcss.3.4.16.css"></script>
    
    <!-- PDF.js for parsing -->
    <script src="/tools/js/pdf.js"></script>
    
    <!-- JSZip for bundling images -->
    <script src="/tools/js/jszip.js"></script>
    
    <!-- FileSaver for saving the zip -->
    <script src="/tools/js/FileSaver.js"></script>

    <!-- Lucide Icons -->
    <script src="/tools/js/lucide.min.js"></script>

    <script>
        // Set the worker source for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = '/js/pdf.worker.js';
    </script>

    <style>
        .drop-zone {
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            background-color: #eff6ff; /* blue-50 */
            border-color: #3b82f6; /* blue-500 */
            transform: scale(1.01);
        }
        /* Custom scrollbar for gallery */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 h-screen flex flex-col font-sans">

    <!-- Header -->
    <header class="bg-white shadow-sm z-10">
        <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <i data-lucide="file-image" class="text-blue-600 w-8 h-8"></i>
                <h1 class="text-xl font-bold text-slate-900">PDF Extractor</h1>
            </div>
            <div class="text-sm text-slate-500">
                100% Client-Side Processing
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 overflow-hidden flex flex-col md:flex-row max-w-7xl mx-auto w-full p-4 gap-6">
        
        <!-- Left Panel: Controls -->
        <div class="w-full md:w-1/3 flex flex-col gap-4">
            
            <!-- Upload Area -->
            <div id="dropZone" class="drop-zone bg-white border-2 border-dashed border-slate-300 rounded-xl p-8 flex flex-col items-center justify-center text-center cursor-pointer h-64 shadow-sm hover:shadow-md relative">
                <input type="file" id="fileInput" accept="application/pdf" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                <div id="uploadContent" class="flex flex-col items-center gap-3 pointer-events-none transition-opacity duration-300">
                    <div class="w-16 h-16 bg-blue-50 text-blue-500 rounded-full flex items-center justify-center mb-2">
                        <i data-lucide="upload-cloud" class="w-8 h-8"></i>
                    </div>
                    <h3 class="font-semibold text-lg">Drop PDF here</h3>
                    <p class="text-slate-400 text-sm">or click to browse</p>
                </div>
                <!-- Processing State -->
                <div id="processingState" class="hidden flex flex-col items-center gap-3 w-full">
                    <div class="w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin"></div>
                    <h3 class="font-medium text-slate-700">Processing PDF...</h3>
                    <p id="progressText" class="text-sm text-slate-500">Scanning Page 0/0</p>
                    <div class="w-full bg-slate-100 rounded-full h-2 mt-2 overflow-hidden">
                        <div id="progressBar" class="bg-blue-600 h-full w-0 transition-all duration-300"></div>
                    </div>
                </div>
            </div>

            <!-- Stats & Actions -->
            <div class="bg-white rounded-xl p-6 shadow-sm border border-slate-100 flex-1 flex flex-col">
                <h3 class="font-semibold text-slate-800 mb-4 flex items-center gap-2">
                    <i data-lucide="bar-chart-2" class="w-4 h-4"></i> Session Stats
                </h3>
                
                <div class="space-y-4 mb-6">
                    <div class="flex justify-between items-center border-b border-slate-100 pb-2">
                        <span class="text-slate-500 text-sm">Pages Scanned</span>
                        <span id="pageCount" class="font-mono font-medium">0</span>
                    </div>
                    <div class="flex justify-between items-center border-b border-slate-100 pb-2">
                        <span class="text-slate-500 text-sm">Images Found</span>
                        <span id="imgCount" class="font-mono font-medium text-blue-600">0</span>
                    </div>
                </div>

                <div class="mt-auto space-y-3">
                    <button id="downloadBtn" disabled class="w-full py-3 px-4 bg-blue-600 hover:bg-blue-700 disabled:bg-slate-300 disabled:cursor-not-allowed text-white rounded-lg font-medium transition-colors flex items-center justify-center gap-2 shadow-lg shadow-blue-200">
                        <i data-lucide="download" class="w-5 h-5"></i> Download ZIP
                    </button>
                    <button id="resetBtn" class="w-full py-2 px-4 bg-white border border-slate-200 hover:bg-slate-50 text-slate-700 rounded-lg font-medium transition-colors">
                        Reset
                    </button>
                </div>
            </div>
        </div>

        <!-- Right Panel: Gallery -->
        <div class="w-full md:w-2/3 bg-white rounded-xl shadow-sm border border-slate-100 flex flex-col overflow-hidden">
            <div class="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50/50">
                <h2 class="font-semibold text-slate-800">Extracted Images</h2>
                <span class="text-xs px-2 py-1 bg-slate-200 text-slate-600 rounded text-center">
                    Right-click to save individually
                </span>
            </div>
            
            <div id="gallery" class="flex-1 overflow-y-auto p-4">
                <!-- Empty State -->
                <div id="emptyState" class="h-full flex flex-col items-center justify-center text-slate-300">
                    <i data-lucide="image" class="w-16 h-16 mb-4 opacity-50"></i>
                    <p>No images extracted yet</p>
                </div>

                <!-- Grid -->
                <div id="imageGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 hidden">
                    <!-- Images injected here -->
                </div>
            </div>
        </div>
    </main>

    <!-- Hidden Canvas for processing -->
    <canvas id="tempCanvas" class="hidden"></canvas>

    <script>
        // Initialize Icons
        lucide.createIcons();

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const uploadContent = document.getElementById('uploadContent');
        const processingState = document.getElementById('processingState');
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        const gallery = document.getElementById('gallery');
        const imageGrid = document.getElementById('imageGrid');
        const emptyState = document.getElementById('emptyState');
        const pageCountEl = document.getElementById('pageCount');
        const imgCountEl = document.getElementById('imgCount');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const tempCanvas = document.getElementById('tempCanvas');
        const ctx = tempCanvas.getContext('2d');

        // State
        let extractedImages = []; // Stores objects { blob, name, id }
        let isProcessing = false;

        // Drag and Drop Effects
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
        });

        dropZone.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles({ target: { files: files } });
        }

        function handleFiles(e) {
            if (isProcessing) return;
            const files = e.target.files;
            if (files && files[0] && files[0].type === "application/pdf") {
                processPDF(files[0]);
            } else {
                alert("Please upload a valid PDF file.");
            }
        }

        // --- Core Logic ---

        async function processPDF(file) {
            resetUI();
            isProcessing = true;
            toggleProcessing(true);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                const totalPages = pdf.numPages;
                let totalImagesFound = 0;

                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    // Update Progress
                    const pct = Math.round((pageNum / totalPages) * 100);
                    progressBar.style.width = `${pct}%`;
                    progressText.textContent = `Scanning Page ${pageNum} of ${totalPages}`;
                    pageCountEl.textContent = pageNum;

                    const page = await pdf.getPage(pageNum);
                    const ops = await page.getOperatorList();
                    
                    // Filter operators to find images
                    // OPS.paintImageXObject (85) and OPS.paintJpegXObject (82) are common
                    for (let i = 0; i < ops.fnArray.length; i++) {
                        const fn = ops.fnArray[i];
                        const args = ops.argsArray[i];

                        if (fn === pdfjsLib.OPS.paintImageXObject || fn === pdfjsLib.OPS.paintJpegXObject) {
                            const imgName = args[0];
                            
                            try {
                                const imgObj = await page.objs.get(imgName);
                                
                                // Validation: Ignore tiny images (often lines or bullet points)
                                if (imgObj && imgObj.width > 20 && imgObj.height > 20) {
                                    await processImageObject(imgObj, pageNum, totalImagesFound + 1);
                                    totalImagesFound++;
                                    imgCountEl.textContent = totalImagesFound;
                                }
                            } catch (err) {
                                console.warn(`Could not extract image ${imgName} on page ${pageNum}`, err);
                            }
                        }
                    }
                    
                    // Cleanup page resources
                    page.cleanup();
                }

                if (extractedImages.length > 0) {
                    downloadBtn.disabled = false;
                } else {
                    alert("No images found in this PDF. It might be scanned (whole pages are images) or contain only vector graphics.");
                }

            } catch (error) {
                console.error(error);
                alert("Error parsing PDF. Is it password protected or corrupted?");
            } finally {
                isProcessing = false;
                toggleProcessing(false);
                // Reset file input so same file can be selected again
                fileInput.value = '';
            }
        }

        async function processImageObject(imgObj, pageNum, imgId) {
            // Determine dimensions
            const width = imgObj.width;
            const height = imgObj.height;
            
            // Resize canvas
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            // Draw image data to canvas
            // If it's a bitmap (modern browsers)
            if (imgObj.bitmap) {
                ctx.drawImage(imgObj.bitmap, 0, 0);
            } else if (imgObj.data) {
                // Fallback for raw data arrays (older PDF.js paths or specific formats)
                // This is a simplified handler. Complex color spaces (CMYK) might look odd without more logic.
                // However, PDF.js usually handles conversion to RGBA in the 'data' property for us.
                const imageData = new ImageData(new Uint8ClampedArray(imgObj.data), width, height);
                ctx.putImageData(imageData, 0, 0);
            } else {
                return; // Unsupported format
            }

            // Convert to Blob (better for memory than DataURL Strings)
            const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
            const url = URL.createObjectURL(blob);
            const fileName = `image_p${pageNum}_${imgId}.png`;

            // Store
            extractedImages.push({
                blob: blob,
                fileName: fileName,
                url: url
            });

            // Add to DOM
            addImageToGallery(url, fileName, width, height);
        }

        function addImageToGallery(url, name, w, h) {
            emptyState.classList.add('hidden');
            imageGrid.classList.remove('hidden');
            imageGrid.classList.add('grid');

            const div = document.createElement('div');
            div.className = "group relative bg-slate-100 rounded-lg overflow-hidden border border-slate-200 aspect-square flex items-center justify-center";
            
            const img = document.createElement('img');
            img.src = url;
            img.className = "max-w-full max-h-full object-contain p-2";
            
            const overlay = document.createElement('div');
            overlay.className = "absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2 text-white";
            
            const info = document.createElement('span');
            info.className = "text-xs font-mono bg-black/50 px-2 py-1 rounded";
            info.textContent = `${w}x${h}`;

            const dlLink = document.createElement('a');
            dlLink.href = url;
            dlLink.download = name;
            dlLink.className = "p-2 bg-white text-black rounded-full hover:scale-110 transition-transform";
            dlLink.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" x2="12" y1="15" y2="3"></line></svg>`;

            overlay.appendChild(info);
            overlay.appendChild(dlLink);
            div.appendChild(img);
            div.appendChild(overlay);
            
            imageGrid.appendChild(div);
        }

        // --- Utils & UI ---

        function toggleProcessing(isBusy) {
            if (isBusy) {
                uploadContent.classList.add('hidden');
                processingState.classList.remove('hidden');
            } else {
                uploadContent.classList.remove('hidden');
                processingState.classList.add('hidden');
                progressText.textContent = "Ready";
                progressBar.style.width = "0%";
            }
        }

        function resetUI() {
            extractedImages = [];
            imageGrid.innerHTML = '';
            imageGrid.classList.add('hidden');
            imageGrid.classList.remove('grid');
            emptyState.classList.remove('hidden');
            pageCountEl.textContent = '0';
            imgCountEl.textContent = '0';
            downloadBtn.disabled = true;
        }

        resetBtn.addEventListener('click', () => {
            resetUI();
            fileInput.value = '';
        });

        // --- Zipping Logic ---

        downloadBtn.addEventListener('click', async () => {
            if (extractedImages.length === 0) return;

            const btnText = downloadBtn.innerHTML;
            downloadBtn.disabled = true;
            downloadBtn.innerHTML = `<svg class="animate-spin h-5 w-5 mr-2" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Zipping...`;

            try {
                const zip = new JSZip();
                const folder = zip.folder("extracted_images");

                extractedImages.forEach(img => {
                    folder.file(img.fileName, img.blob);
                });

                const content = await zip.generateAsync({type:"blob"});
                saveAs(content, "pdf_images.zip");

            } catch (err) {
                console.error("Zip failed", err);
                alert("Failed to generate Zip file");
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = btnText;
            }
        });

    </script>
</body>
</html>